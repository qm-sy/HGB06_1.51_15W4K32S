C51 COMPILER V9.60.7.0   TIMER                                                             04/03/2025 14:49:13 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE TIMER
OBJECT MODULE PLACED IN .\Output\timer.obj
COMPILER INVOKED BY: D:\APP\Keil_v5\C51\BIN\C51.EXE Src\timer.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\Inc;D:\APP\Keil_
                    -v5\C51\INC) DEBUG OBJECTEXTEND PRINT(.\Listings\timer.lst) OBJECT(.\Output\timer.obj)

line level    source

   1          #include "STC15W4Kxx.h"
   2          #include "timer.h"
   3          #include "stdint.h"
   4          #include "key.h"
   5          #include "adc.h"
   6          #include "ntc.h"
   7          
   8          bit fan_dis_bit = 0;
   9          bit temp_dis_bit = 0;
  10          bit zero_bit = 0;
  11          bit buzzer_bit = 1;
  12          bit scan_stop_bit = 1;
  13          bit scan_start_bit = 0;  
  14          bit master_pwm_bit = 0;
  15          bit power_bit = 1;
  16          bit power_bit2 = 0;
  17          bit wind_bit = 1;
  18          bit previous_value = 0;
  19          bit delay_bit1 = 0;
  20          bit delay_bit2 = 0;
  21          bit delay_bit3 = 0;
  22          bit temp_listen_bit = 0;
  23          bit button_scan_flag = 0;
  24          uint16_t button_scan_cnt = 0;
  25          uint16_t pwm_adc_val = 0;
  26          volatile uint16_t ntc6_val = 0;
  27          uint8_t pwm_adc_cnt = 0;
  28          uint8_t channel_num = 1;
  29          uint16_t tim1_t = 58400;
  30          uint8_t pwm_num_cnt = 0;
  31          uint8_t temp_listen_cnt = 1;
  32          uint8_t fengshan_delay = 5;
  33          
  34          void Tim0Init()         //11.0592Mhz  2333us
  35          {
  36   1              AUXR &= 0x7F;                   //定时器时钟12T模式
  37   1              TMOD &= 0xF0;                   //设置定时器模式
  38   1              TL0 = 0x9A;                             //设置定时初始值
  39   1              TH0 = 0xF7;                             //设置定时初始值
  40   1              TF0 = 0;                                //清除TF0标志
  41   1              TR0 = 1;                                //定时器0开始计时
  42   1      
  43   1              ET0 = 1;            //打开IE-ET0，TIM0中断
  44   1      }
  45          
  46          
  47          void Tim1Init()         //11.0592Mhz  10ms  16位手动装载
  48          {   
  49   1              AUXR &= 0xBF;       //定时器时钟12T模式
  50   1              TMOD &= 0x0F;       //设置定时器模式
  51   1              TMOD |= 0x10;       //设置定时器模式   手动/自动开关
  52   1      }
  53          
  54          void Tim3Init(void)             //10毫秒@11.0592MHz
C51 COMPILER V9.60.7.0   TIMER                                                             04/03/2025 14:49:13 PAGE 2   

  55          {
  56   1              T4T3M &= 0xFD;      //定时器时钟12T模式
  57   1              T3L = 0x00;         //设置定时初始值
  58   1              T3H = 0xDC;         //设置定时初始值
  59   1              T4T3M |= 0x08;      //定时器3开始计时
  60   1          
  61   1          IE2 |= 0x20; //打开IE2-ET2，TIM3中断
  62   1      }
  63          
  64          void ET0ISR(void) interrupt 0 
  65          {
  66   1          tempchannel1 = tempchannel2 = 1;    
  67   1              /*延时移相*/
  68   1          TL1 = tim1_t;                               //设置定时初始值
  69   1              TH1 = tim1_t>>8;                                //设置定时初始值
  70   1      
  71   1          zero_bit = 1;
  72   1          
  73   1          TR1 = 1;                            //定时器1开始计时      
  74   1          ET1 = 1; 
  75   1      }
  76          
  77          void Tim0Isr(void) interrupt 1 
  78          {
  79   1          static uint8_t lunzhuan = 0;
  80   1          if( lunzhuan == 0 )
  81   1          {
  82   2              pwm_adc_val = Get_ADC12bitResult(7);
  83   2              if( pwm_adc_val < 500 )
  84   2              {
  85   3                  pwm_adc_cnt++;
  86   3                  if( pwm_adc_cnt == 100 ) 
  87   3                  {
  88   4                      pwm_adc_cnt    = 0;
  89   4                      master_pwm_bit = 0; 
  90   4                      previous_value = 0;
  91   4                  }
  92   3              }
  93   2              if( pwm_adc_val > 800 )
  94   2              {
  95   3                  pwm_adc_cnt = 0;
  96   3                  master_pwm_bit = 1;
  97   3                  previous_value = 1;
  98   3              }
  99   2          }else
 100   1          {
 101   2              if(temp_listen_bit == 0)
 102   2              {
 103   3                  temp_listen_cnt++;
 104   3                  if(temp_listen_cnt>20)
 105   3                  {
 106   4                      ntc6_val = get_temp(6);
 107   4                      temp_listen_bit = 1;
 108   4                      temp_listen_cnt = 0;
 109   4                  }
 110   3              }
 111   2          }
 112   1          lunzhuan = 1-lunzhuan;
 113   1      }
 114          
 115          void Tim1Isr(void) interrupt 3 
 116          {
C51 COMPILER V9.60.7.0   TIMER                                                             04/03/2025 14:49:13 PAGE 3   

 117   1      
 118   1          if((zero_bit == 1)&&(power_bit == 1))
 119   1          {
 120   2      
 121   2                  /*发送一个10us的脉冲*/
 122   2                  switch(channel_num)
 123   2                  {
 124   3                      case 1: {tempchannel1=0; tempchannel2=1;}break;
 125   3                      case 2: {tempchannel1=1; tempchannel2=0; }break;
 126   3                      case 3: {tempchannel1=0; tempchannel2=0;}break;
 127   3                      // case 4: {tempchannel1=0; tempchannel2=0; tempchannel3=1;}break;
 128   3                      // case 5: {tempchannel1=1; tempchannel2=0; tempchannel3=0;}break;
 129   3                      // case 6: {tempchannel1=0; tempchannel2=1; tempchannel3=0;}break;
 130   3                      // case 7: {tempchannel1=0; tempchannel2=0; tempchannel3=0;}break;
 131   3                      default: break;
 132   3                  }
 133   2                  zero_bit = 0; 
 134   2      
 135   2                  TL1 = 0xF7;                         //设置定时初始值
 136   2                  TH1 = 0xFF;                         //设置定时初始值
 137   2          }
 138   1        
 139   1          else
 140   1          {
 141   2              tempchannel1 = tempchannel2 = 1;    //1-0-1的脉冲 2us
 142   2              TR1 = 0;                                //定时器关闭计时      
 143   2              ET1 = 0; 
 144   2          }
 145   1      }
 146          
 147          void Tim3Isr(void) interrupt 19 
 148          {
 149   1          static uint8_t buzzer_continue_cnt = 0;
 150   1          static uint8_t sacn_cnt = 0;
 151   1          static uint8_t key_cnt = 0;
 152   1          static uint8_t sync_delay_cnt = 0;
 153   1          static uint8_t temp_delay_cnt = 0;
 154   1          static uint8_t fan_rotate_cnt = 0;
 155   1          static uint8_t temp_rotate_cnt = 0;
 156   1          static uint16_t fan_delay_cnt = 0;
 157   1          
 158   1          if((delay_bit1 == 1)&&(delay_bit2 == 1))
 159   1          {
 160   2              fan_delay_cnt++;
 161   2              if(fan_delay_cnt == fengshan_delay*100)
 162   2              {
 163   3                  fan_delay_cnt = 0;
 164   3                  delay_bit1 = 0;
 165   3                  delay_bit2 = 0;
 166   3                  delay_bit3 = 1;
 167   3              }
 168   2          }
 169   1          if((delay_bit1&delay_bit2)==0)
 170   1          {
 171   2              fan_delay_cnt = 0;
 172   2          }
 173   1      //    if((delay_bit1 == 1)&&(delay_bit2 == 0))
 174   1      //    {
 175   1      //        fan_delay_cnt = 0;
 176   1      //    }
 177   1          fan_rotate_cnt++;
 178   1          if(fan_rotate_cnt>15)
C51 COMPILER V9.60.7.0   TIMER                                                             04/03/2025 14:49:13 PAGE 4   

 179   1          {
 180   2              fan_dis_bit = ~fan_dis_bit;
 181   2              fan_rotate_cnt = 0;
 182   2          }
 183   1          
 184   1          temp_rotate_cnt++;
 185   1          if(temp_rotate_cnt>50)
 186   1          {
 187   2              temp_dis_bit = ~temp_dis_bit;
 188   2              temp_rotate_cnt = 0;
 189   2          }
 190   1          
 191   1          key_cnt++;
 192   1          if(key_cnt>5)
 193   1          {
 194   2              key_cnt=0; 
 195   2              key_val = (P0&0X0f);
 196   2          }
 197   1          
 198   1          if(sync_delay_bit == 1)
 199   1          {
 200   2              sync_delay_cnt++;
 201   2              if(sync_delay_cnt>150)
 202   2              {
 203   3                  sync_delay_bit = 0;
 204   3                  sync_delay_cnt = 0;
 205   3              }
 206   2          }
 207   1      
 208   1          if(temp_delay_bit == 1)
 209   1          {
 210   2              temp_delay_cnt++;
 211   2              if(temp_delay_cnt>150)
 212   2              {
 213   3                  temp_delay_bit = 0;
 214   3                  temp_delay_cnt = 0;
 215   3              }
 216   2          }
 217   1          
 218   1          if(buzzer_bit==0)
 219   1          {
 220   2              buzzer_continue_cnt++;
 221   2              if(buzzer_continue_cnt>10)
 222   2              {
 223   3                  buzzer_continue_cnt=0; 
 224   3                  buzzer=buzzer_bit=1;
 225   3              }
 226   2          } 
 227   1          
 228   1          if(scan_stop_bit == 1)
 229   1          {
 230   2              sacn_cnt++;
 231   2              if(sacn_cnt>10)
 232   2              {
 233   3                  scan_start_bit = 1;
 234   3                  scan_stop_bit = 0;
 235   3                  sacn_cnt = 0;
 236   3              }
 237   2          }
 238   1      
 239   1          if( button_scan_flag == 1 )
 240   1          {
C51 COMPILER V9.60.7.0   TIMER                                                             04/03/2025 14:49:13 PAGE 5   

 241   2              button_scan_cnt++;
 242   2              if( button_scan_cnt == 1500 )
 243   2              {
 244   3                  button_scan_flag = 0;
 245   3                  button_scan_cnt  = 0;
 246   3                  P24 = P25 = P26 = 1;
 247   3                  P43 = P44 = 1;
 248   3              }
 249   2          }
 250   1             
 251   1      //    if(P07==0)
 252   1      //    {
 253   1      //        master_pwm_bit = 1;   //24V接入
 254   1      //        previous_value = 1;
 255   1      //    }
 256   1      //    if(P07==1)
 257   1      //    {
 258   1      //        master_pwm_bit = 0;
 259   1      //        previous_value = 0;
 260   1      //    }
 261   1      //    
 262   1          
 263   1      
 264   1      }
 265          
 266          void power_crl(uint8_t power_num)
 267          { 
 268   1          if(power_bit==1)
 269   1          {
 270   2              ET1 = 1;
 271   2          }
 272   1          else
 273   1          {
 274   2              ET1 = 0;
 275   2          }
 276   1          
 277   1          tim1_t = power_num*64+58400;
 278   1          
 279   1      //    TL1 = tim1_t;                   //设置定时初始值
 280   1      //    TH1 = tim1_t>>8;                          //设置定时初始值
 281   1      
 282   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    637    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     23    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =     16    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
